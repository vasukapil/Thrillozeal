{"version":3,"file":"index.es.js","sources":["../src/index.js"],"sourcesContent":["import React, { Component } from 'react';\nimport PropTypes from 'prop-types';\nimport './magic-dots.css';\n\nexport default class MagicSliderDots extends Component {\n  constructor(props) {\n    super(props);\n\n    // init\n    this.previousActiveIndex = 0;\n    this.hasAnimated = false;\n    this.minIndex = 0;\n    this.maxIndex = 0;\n    this.breakPointActiveIndex = 0;\n    this.addActiveClassToLastDot = false;\n  }\n\n  //handle react-slick breakpoints\n  componentDidUpdate(prevProps) {\n    const prevDots = prevProps.dots;\n    const { dots: currentDots, activeDotClassName, numDotsToShow } = this.props;\n\n    //moving from more dots to less dots\n    if (prevDots && currentDots && prevDots.length > currentDots.length) {\n      //edge case - last dot was active\n      if (prevDots[prevDots.length - 1].props.className === activeDotClassName) {\n        this.breakPointActiveIndex = currentDots.length - 1;\n        this.previousActiveIndex = this.breakPointActiveIndex - 1;\n        this.addActiveClassToLastDot = true;\n      }\n\n      //edge case - last active index is at end of current dots or exceeds current dot length\n      const lastActiveDot = prevDots.find(dot => dot.props.className === activeDotClassName);\n      let lastActiveIndex = parseInt(lastActiveDot.key);\n\n      if (lastActiveIndex > currentDots.length - 1) {\n        this.breakPointActiveIndex = currentDots.length - 1;\n        this.previousActiveIndex = this.breakPointActiveIndex - 1;\n        this.addActiveClassToLastDot = true;\n      }\n\n      //adjust minIndex and maxIndex if necessary\n      if (this.minIndex < 0) {\n        this.minIndex = 0;\n        this.maxIndex = numDotsToShow - 1;\n      }\n\n      if (this.maxIndex > currentDots.length - 1) {\n        this.maxIndex = currentDots.length - 1;\n        this.minIndex = this.maxIndex - numDotsToShow + 1;\n      }\n\n      this.forceUpdate();\n    } else if (prevDots && currentDots && prevDots.length < currentDots.length) {\n      //edge case - adjust minIndex and maxIndex if active dot will be out of the View determined by min/max index\n      const currentActiveDot = currentDots.find(dot => dot.props.className === activeDotClassName);\n      let currentActiveIndex = parseInt(currentActiveDot.key);\n\n      if (currentActiveIndex >= this.maxIndex) {\n        this.maxIndex = currentActiveIndex + 1;\n        this.minIndex = this.maxIndex - numDotsToShow + 1;\n      }\n\n      //adjust minIndex and maxIndex if necessary\n      if (this.maxIndex > currentDots.length - 1) {\n        this.maxIndex = currentDots.length - 1;\n        this.minIndex = this.maxIndex - numDotsToShow + 1;\n      }\n\n      this.forceUpdate();\n    }\n  }\n\n  render() {\n    const {\n      dots,\n      numDotsToShow,\n      dotWidth,\n      dotContainerClassName,\n      activeDotClassName,\n      prevNextDotClassName\n    } = this.props;\n\n    const active = dots.find(dot => dot.props.className === activeDotClassName);\n    let adjustedDots = [...dots];\n    //if no current activeIndex, then due to react-slick breakpoint - use generated breakPointActiveIndex\n    let activeIndex = active ? parseInt(active.key) : this.breakPointActiveIndex;\n    //consider '>=' as moving forward to support react-slick breakpoint use case\n    const isMovingForward = activeIndex >= this.previousActiveIndex;\n\n    // need to subtract 2 from numDotsToShow since array index are zero-based\n    if (\n      (activeIndex > numDotsToShow - 2 && adjustedDots.length > numDotsToShow) ||\n      this.hasAnimated\n    ) {\n      if (isMovingForward) {\n        if (activeIndex === this.maxIndex && activeIndex !== dots.length - 1) {\n          // list will move left\n          this.minIndex = activeIndex - (numDotsToShow - 2);\n          this.maxIndex = activeIndex + 1;\n        } else {\n          // special case - handle if initialSlide from react-slick has a value greater than 0\n          if (this.minIndex === 0 && this.maxIndex === 0) {\n            if (activeIndex === dots.length - 1) {\n              this.maxIndex = activeIndex;\n              this.minIndex = this.maxIndex - (numDotsToShow - 1);\n            } else {\n              this.minIndex = activeIndex - 1 < 0 ? 0 : activeIndex - 1;\n              this.maxIndex =\n                this.minIndex + (numDotsToShow - 1) > dots.length - 1\n                  ? dots.length - 1\n                  : this.minIndex + (numDotsToShow - 1);\n            }\n          } else {\n            if (activeIndex === dots.length - 1) {\n              // moving carousel backward from 0 to max index\n              this.maxIndex = dots.length - 1;\n              this.minIndex = dots.length - numDotsToShow;\n            }\n          }\n        }\n      } else {\n        // movingBackwards\n        if (activeIndex === this.minIndex && activeIndex !== 0) {\n          // list will move right\n          this.minIndex = activeIndex - 1;\n          this.maxIndex = this.minIndex + (numDotsToShow - 1);\n        } else {\n          if (activeIndex === 0) {\n            // moving carousel forward from max index to 0\n            this.maxIndex = numDotsToShow - 1;\n            this.minIndex = 0;\n          }\n        }\n      }\n\n      this.hasAnimated = true;\n      const firstViewableDotIndex = this.minIndex;\n      const firstViewableDot = adjustedDots[firstViewableDotIndex];\n      const lastViewableDotIndex = this.maxIndex;\n      const lastViewableDot = adjustedDots[lastViewableDotIndex];\n\n      //outside of bounds check - can be caused when using react-slick breakpoints\n      //return null and dots will correctly re-render once componentDidUpdate lifecycle recalculates indexes\n      if (!firstViewableDot || !lastViewableDot) {\n        console.log('rendering null - outside of bounds', firstViewableDot, lastViewableDot);\n        return null;\n      }\n\n      if (lastViewableDotIndex < adjustedDots.length - 1 && isMovingForward) {\n        // moving foward - but not on the last dot\n        adjustedDots = [\n          ...adjustedDots.slice(0, firstViewableDotIndex),\n          React.cloneElement(firstViewableDot, {\n            className: prevNextDotClassName\n          }),\n          ...adjustedDots.slice(firstViewableDotIndex + 1, lastViewableDotIndex),\n          React.cloneElement(lastViewableDot, {\n            className: prevNextDotClassName\n          }),\n          ...adjustedDots.slice(lastViewableDotIndex + 1)\n        ];\n      } else if (lastViewableDotIndex === adjustedDots.length - 1) {\n        // moving foward or backward - last dot visible - should appear not small\n        adjustedDots = [\n          ...adjustedDots.slice(0, firstViewableDotIndex),\n          React.cloneElement(firstViewableDot, {\n            className: prevNextDotClassName\n          }),\n          ...adjustedDots.slice(firstViewableDotIndex + 1, lastViewableDotIndex),\n          this.addActiveClassToLastDot || activeIndex === lastViewableDotIndex\n            ? React.cloneElement(lastViewableDot, {\n                className: this.props.activeDotClassName\n              })\n            : lastViewableDot\n        ];\n      } else if (activeIndex > 1 && !isMovingForward) {\n        // moving backwards the left\n        adjustedDots = [\n          ...adjustedDots.slice(0, firstViewableDotIndex),\n          React.cloneElement(firstViewableDot, {\n            className: prevNextDotClassName\n          }),\n          ...adjustedDots.slice(firstViewableDotIndex + 1, lastViewableDotIndex),\n          React.cloneElement(lastViewableDot, {\n            className: prevNextDotClassName\n          }),\n          ...adjustedDots.slice(lastViewableDotIndex + 1)\n        ];\n      } else {\n        this.hasAnimated = false;\n        // moving backwards on first dot - should appear not small\n        // eq: (activeIndex === 1 || activeIndex === 0) && !isMovingForward\n        adjustedDots = [\n          ...adjustedDots.slice(0, lastViewableDotIndex),\n          React.cloneElement(lastViewableDot, {\n            className: prevNextDotClassName\n          }),\n          ...adjustedDots.slice(lastViewableDotIndex + 1)\n        ];\n      }\n    }\n    // no leftOffset in place, just render the dots\n    else {\n      const lastViewableDotIndex = Math.min(numDotsToShow, dots.length) - 1;\n      this.minIndex = 0;\n      this.maxIndex = lastViewableDotIndex;\n\n      if (lastViewableDotIndex < adjustedDots.length - 1) {\n        const lastViewableDot = adjustedDots[lastViewableDotIndex];\n\n        adjustedDots = [\n          ...adjustedDots.slice(0, lastViewableDotIndex),\n          React.cloneElement(lastViewableDot, {\n            className: prevNextDotClassName\n          }),\n          ...adjustedDots.slice(lastViewableDotIndex + 1)\n        ];\n      }\n    }\n\n    // track active index\n    this.previousActiveIndex = activeIndex;\n    this.addActiveClassToLastDot = false;\n    // calculate container width\n    const containerWidth =\n      dots.length < numDotsToShow ? dots.length * dotWidth : numDotsToShow * dotWidth;\n\n    const midIndex = (this.minIndex + this.maxIndex) / 2;\n\n    // only give leftOffset if number of dots exceeds number of dots to show at one time\n    const leftOffset =\n      dots.length < numDotsToShow\n        ? 0\n        : (dotWidth * numDotsToShow - dotWidth) / 2 - midIndex * dotWidth;\n\n    return (\n      <div\n        className={dotContainerClassName}\n        style={{\n          position: 'relative',\n          overflow: 'hidden',\n          margin: 'auto',\n          width: containerWidth + 'px'\n        }}\n      >\n        <ul style={{ transform: `translateX(${leftOffset}px)` }}> {adjustedDots} </ul>\n      </div>\n    );\n  }\n}\n\nMagicSliderDots.propTypes = {\n  /** array of HTML li elements representing the slider dot.   */\n  dots: PropTypes.array.isRequired,\n  /** number of slider dots to show. */\n  numDotsToShow: PropTypes.number.isRequired,\n  /** width, in pixels, of a slider dot including any margins/padding. */\n  dotWidth: PropTypes.number.isRequired,\n  /** class name of parent div. */\n  dotContainerClassName: PropTypes.string,\n  /** class name of active slider dot. */\n  activeDotClassName: PropTypes.string,\n  /** class name of left-most (prev) and right-most (next) slider dot. */\n  prevNextDotClassName: PropTypes.string\n};\n\nMagicSliderDots.defaultProps = {\n  dotContainerClassName: 'magic-dots slick-dots',\n  activeDotClassName: 'slick-active',\n  prevNextDotClassName: 'small'\n};\n"],"names":["MagicSliderDots","props","previousActiveIndex","hasAnimated","minIndex","maxIndex","breakPointActiveIndex","addActiveClassToLastDot","prevProps","prevDots","dots","currentDots","activeDotClassName","numDotsToShow","length","className","lastActiveDot","find","dot","lastActiveIndex","parseInt","key","forceUpdate","currentActiveDot","currentActiveIndex","dotWidth","dotContainerClassName","prevNextDotClassName","active","adjustedDots","activeIndex","isMovingForward","firstViewableDotIndex","firstViewableDot","lastViewableDotIndex","lastViewableDot","log","slice","React","cloneElement","Math","min","containerWidth","midIndex","leftOffset","transform","Component","propTypes","PropTypes","array","isRequired","number","string","defaultProps"],"mappings":"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"}