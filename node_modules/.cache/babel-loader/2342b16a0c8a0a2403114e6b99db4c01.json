{"ast":null,"code":"import React, { Component } from 'react';\nimport PropTypes from 'prop-types';\n\nvar classCallCheck = function (instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\nvar createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar inherits = function (subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n};\n\nvar possibleConstructorReturn = function (self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n};\n\nvar toConsumableArray = function (arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n};\n\nvar MagicSliderDots = function (_Component) {\n  inherits(MagicSliderDots, _Component);\n\n  function MagicSliderDots(props) {\n    classCallCheck(this, MagicSliderDots); // init\n\n    var _this = possibleConstructorReturn(this, (MagicSliderDots.__proto__ || Object.getPrototypeOf(MagicSliderDots)).call(this, props));\n\n    _this.previousActiveIndex = 0;\n    _this.hasAnimated = false;\n    _this.minIndex = 0;\n    _this.maxIndex = 0;\n    _this.breakPointActiveIndex = 0;\n    _this.addActiveClassToLastDot = false;\n    return _this;\n  } //handle react-slick breakpoints\n\n\n  createClass(MagicSliderDots, [{\n    key: 'componentDidUpdate',\n    value: function componentDidUpdate(prevProps) {\n      var prevDots = prevProps.dots;\n      var _props = this.props,\n          currentDots = _props.dots,\n          activeDotClassName = _props.activeDotClassName,\n          numDotsToShow = _props.numDotsToShow; //moving from more dots to less dots\n\n      if (prevDots && currentDots && prevDots.length > currentDots.length) {\n        //edge case - last dot was active\n        if (prevDots[prevDots.length - 1].props.className === activeDotClassName) {\n          this.breakPointActiveIndex = currentDots.length - 1;\n          this.previousActiveIndex = this.breakPointActiveIndex - 1;\n          this.addActiveClassToLastDot = true;\n        } //edge case - last active index is at end of current dots or exceeds current dot length\n\n\n        var lastActiveDot = prevDots.find(function (dot) {\n          return dot.props.className === activeDotClassName;\n        });\n        var lastActiveIndex = parseInt(lastActiveDot.key);\n\n        if (lastActiveIndex > currentDots.length - 1) {\n          this.breakPointActiveIndex = currentDots.length - 1;\n          this.previousActiveIndex = this.breakPointActiveIndex - 1;\n          this.addActiveClassToLastDot = true;\n        } //adjust minIndex and maxIndex if necessary\n\n\n        if (this.minIndex < 0) {\n          this.minIndex = 0;\n          this.maxIndex = numDotsToShow - 1;\n        }\n\n        if (this.maxIndex > currentDots.length - 1) {\n          this.maxIndex = currentDots.length - 1;\n          this.minIndex = this.maxIndex - numDotsToShow + 1;\n        }\n\n        this.forceUpdate();\n      } else if (prevDots && currentDots && prevDots.length < currentDots.length) {\n        //edge case - adjust minIndex and maxIndex if active dot will be out of the View determined by min/max index\n        var currentActiveDot = currentDots.find(function (dot) {\n          return dot.props.className === activeDotClassName;\n        });\n        var currentActiveIndex = parseInt(currentActiveDot.key);\n\n        if (currentActiveIndex >= this.maxIndex) {\n          this.maxIndex = currentActiveIndex + 1;\n          this.minIndex = this.maxIndex - numDotsToShow + 1;\n        } //adjust minIndex and maxIndex if necessary\n\n\n        if (this.maxIndex > currentDots.length - 1) {\n          this.maxIndex = currentDots.length - 1;\n          this.minIndex = this.maxIndex - numDotsToShow + 1;\n        }\n\n        this.forceUpdate();\n      }\n    }\n  }, {\n    key: 'render',\n    value: function render() {\n      var _props2 = this.props,\n          dots = _props2.dots,\n          numDotsToShow = _props2.numDotsToShow,\n          dotWidth = _props2.dotWidth,\n          dotContainerClassName = _props2.dotContainerClassName,\n          activeDotClassName = _props2.activeDotClassName,\n          prevNextDotClassName = _props2.prevNextDotClassName;\n      var active = dots.find(function (dot) {\n        return dot.props.className === activeDotClassName;\n      });\n      var adjustedDots = [].concat(toConsumableArray(dots)); //if no current activeIndex, then due to react-slick breakpoint - use generated breakPointActiveIndex\n\n      var activeIndex = active ? parseInt(active.key) : this.breakPointActiveIndex; //consider '>=' as moving forward to support react-slick breakpoint use case\n\n      var isMovingForward = activeIndex >= this.previousActiveIndex; // need to subtract 2 from numDotsToShow since array index are zero-based\n\n      if (activeIndex > numDotsToShow - 2 && adjustedDots.length > numDotsToShow || this.hasAnimated) {\n        if (isMovingForward) {\n          if (activeIndex === this.maxIndex && activeIndex !== dots.length - 1) {\n            // list will move left\n            this.minIndex = activeIndex - (numDotsToShow - 2);\n            this.maxIndex = activeIndex + 1;\n          } else {\n            // special case - handle if initialSlide from react-slick has a value greater than 0\n            if (this.minIndex === 0 && this.maxIndex === 0) {\n              if (activeIndex === dots.length - 1) {\n                this.maxIndex = activeIndex;\n                this.minIndex = this.maxIndex - (numDotsToShow - 1);\n              } else {\n                this.minIndex = activeIndex - 1 < 0 ? 0 : activeIndex - 1;\n                this.maxIndex = this.minIndex + (numDotsToShow - 1) > dots.length - 1 ? dots.length - 1 : this.minIndex + (numDotsToShow - 1);\n              }\n            } else {\n              if (activeIndex === dots.length - 1) {\n                // moving carousel backward from 0 to max index\n                this.maxIndex = dots.length - 1;\n                this.minIndex = dots.length - numDotsToShow;\n              }\n            }\n          }\n        } else {\n          // movingBackwards\n          if (activeIndex === this.minIndex && activeIndex !== 0) {\n            // list will move right\n            this.minIndex = activeIndex - 1;\n            this.maxIndex = this.minIndex + (numDotsToShow - 1);\n          } else {\n            if (activeIndex === 0) {\n              // moving carousel forward from max index to 0\n              this.maxIndex = numDotsToShow - 1;\n              this.minIndex = 0;\n            }\n          }\n        }\n\n        this.hasAnimated = true;\n        var firstViewableDotIndex = this.minIndex;\n        var firstViewableDot = adjustedDots[firstViewableDotIndex];\n        var lastViewableDotIndex = this.maxIndex;\n        var lastViewableDot = adjustedDots[lastViewableDotIndex]; //outside of bounds check - can be caused when using react-slick breakpoints\n        //return null and dots will correctly re-render once componentDidUpdate lifecycle recalculates indexes\n\n        if (!firstViewableDot || !lastViewableDot) {\n          console.log('rendering null - outside of bounds', firstViewableDot, lastViewableDot);\n          return null;\n        }\n\n        if (lastViewableDotIndex < adjustedDots.length - 1 && isMovingForward) {\n          // moving foward - but not on the last dot\n          adjustedDots = [].concat(toConsumableArray(adjustedDots.slice(0, firstViewableDotIndex)), [React.cloneElement(firstViewableDot, {\n            className: prevNextDotClassName\n          })], toConsumableArray(adjustedDots.slice(firstViewableDotIndex + 1, lastViewableDotIndex)), [React.cloneElement(lastViewableDot, {\n            className: prevNextDotClassName\n          })], toConsumableArray(adjustedDots.slice(lastViewableDotIndex + 1)));\n        } else if (lastViewableDotIndex === adjustedDots.length - 1) {\n          // moving foward or backward - last dot visible - should appear not small\n          adjustedDots = [].concat(toConsumableArray(adjustedDots.slice(0, firstViewableDotIndex)), [React.cloneElement(firstViewableDot, {\n            className: prevNextDotClassName\n          })], toConsumableArray(adjustedDots.slice(firstViewableDotIndex + 1, lastViewableDotIndex)), [this.addActiveClassToLastDot || activeIndex === lastViewableDotIndex ? React.cloneElement(lastViewableDot, {\n            className: this.props.activeDotClassName\n          }) : lastViewableDot]);\n        } else if (activeIndex > 1 && !isMovingForward) {\n          // moving backwards the left\n          adjustedDots = [].concat(toConsumableArray(adjustedDots.slice(0, firstViewableDotIndex)), [React.cloneElement(firstViewableDot, {\n            className: prevNextDotClassName\n          })], toConsumableArray(adjustedDots.slice(firstViewableDotIndex + 1, lastViewableDotIndex)), [React.cloneElement(lastViewableDot, {\n            className: prevNextDotClassName\n          })], toConsumableArray(adjustedDots.slice(lastViewableDotIndex + 1)));\n        } else {\n          this.hasAnimated = false; // moving backwards on first dot - should appear not small\n          // eq: (activeIndex === 1 || activeIndex === 0) && !isMovingForward\n\n          adjustedDots = [].concat(toConsumableArray(adjustedDots.slice(0, lastViewableDotIndex)), [React.cloneElement(lastViewableDot, {\n            className: prevNextDotClassName\n          })], toConsumableArray(adjustedDots.slice(lastViewableDotIndex + 1)));\n        }\n      } // no leftOffset in place, just render the dots\n      else {\n        var _lastViewableDotIndex = Math.min(numDotsToShow, dots.length) - 1;\n\n        this.minIndex = 0;\n        this.maxIndex = _lastViewableDotIndex;\n\n        if (_lastViewableDotIndex < adjustedDots.length - 1) {\n          var _lastViewableDot = adjustedDots[_lastViewableDotIndex];\n          adjustedDots = [].concat(toConsumableArray(adjustedDots.slice(0, _lastViewableDotIndex)), [React.cloneElement(_lastViewableDot, {\n            className: prevNextDotClassName\n          })], toConsumableArray(adjustedDots.slice(_lastViewableDotIndex + 1)));\n        }\n      } // track active index\n\n\n      this.previousActiveIndex = activeIndex;\n      this.addActiveClassToLastDot = false; // calculate container width\n\n      var containerWidth = dots.length < numDotsToShow ? dots.length * dotWidth : numDotsToShow * dotWidth;\n      var midIndex = (this.minIndex + this.maxIndex) / 2; // only give leftOffset if number of dots exceeds number of dots to show at one time\n\n      var leftOffset = dots.length < numDotsToShow ? 0 : (dotWidth * numDotsToShow - dotWidth) / 2 - midIndex * dotWidth;\n      return React.createElement('div', {\n        className: dotContainerClassName,\n        style: {\n          position: 'relative',\n          overflow: 'hidden',\n          margin: 'auto',\n          width: containerWidth + 'px'\n        }\n      }, React.createElement('ul', {\n        style: {\n          transform: 'translateX(' + leftOffset + 'px)'\n        }\n      }, ' ', adjustedDots, ' '));\n    }\n  }]);\n  return MagicSliderDots;\n}(Component);\n\nMagicSliderDots.propTypes = {\n  /** array of HTML li elements representing the slider dot.   */\n  dots: PropTypes.array.isRequired,\n\n  /** number of slider dots to show. */\n  numDotsToShow: PropTypes.number.isRequired,\n\n  /** width, in pixels, of a slider dot including any margins/padding. */\n  dotWidth: PropTypes.number.isRequired,\n\n  /** class name of parent div. */\n  dotContainerClassName: PropTypes.string,\n\n  /** class name of active slider dot. */\n  activeDotClassName: PropTypes.string,\n\n  /** class name of left-most (prev) and right-most (next) slider dot. */\n  prevNextDotClassName: PropTypes.string\n};\nMagicSliderDots.defaultProps = {\n  dotContainerClassName: 'magic-dots slick-dots',\n  activeDotClassName: 'slick-active',\n  prevNextDotClassName: 'small'\n};\nexport default MagicSliderDots;","map":{"version":3,"mappings":"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","names":["MagicSliderDots","props","previousActiveIndex","hasAnimated","minIndex","maxIndex","breakPointActiveIndex","addActiveClassToLastDot","prevProps","prevDots","dots","currentDots","activeDotClassName","numDotsToShow","length","className","lastActiveDot","find","dot","lastActiveIndex","parseInt","key","forceUpdate","currentActiveDot","currentActiveIndex","dotWidth","dotContainerClassName","prevNextDotClassName","active","adjustedDots","activeIndex","isMovingForward","firstViewableDotIndex","firstViewableDot","lastViewableDotIndex","lastViewableDot","log","slice","React","cloneElement","Math","min","containerWidth","midIndex","leftOffset","style","transform","Component","propTypes","PropTypes","array","isRequired","number","string","defaultProps"],"sources":["/Users/sudhirkumar/Website/thrillozeal/node_modules/react-magic-slider-dots/src/index.js"],"sourcesContent":["import React, { Component } from 'react';\nimport PropTypes from 'prop-types';\nimport './magic-dots.css';\n\nexport default class MagicSliderDots extends Component {\n  constructor(props) {\n    super(props);\n\n    // init\n    this.previousActiveIndex = 0;\n    this.hasAnimated = false;\n    this.minIndex = 0;\n    this.maxIndex = 0;\n    this.breakPointActiveIndex = 0;\n    this.addActiveClassToLastDot = false;\n  }\n\n  //handle react-slick breakpoints\n  componentDidUpdate(prevProps) {\n    const prevDots = prevProps.dots;\n    const { dots: currentDots, activeDotClassName, numDotsToShow } = this.props;\n\n    //moving from more dots to less dots\n    if (prevDots && currentDots && prevDots.length > currentDots.length) {\n      //edge case - last dot was active\n      if (prevDots[prevDots.length - 1].props.className === activeDotClassName) {\n        this.breakPointActiveIndex = currentDots.length - 1;\n        this.previousActiveIndex = this.breakPointActiveIndex - 1;\n        this.addActiveClassToLastDot = true;\n      }\n\n      //edge case - last active index is at end of current dots or exceeds current dot length\n      const lastActiveDot = prevDots.find(dot => dot.props.className === activeDotClassName);\n      let lastActiveIndex = parseInt(lastActiveDot.key);\n\n      if (lastActiveIndex > currentDots.length - 1) {\n        this.breakPointActiveIndex = currentDots.length - 1;\n        this.previousActiveIndex = this.breakPointActiveIndex - 1;\n        this.addActiveClassToLastDot = true;\n      }\n\n      //adjust minIndex and maxIndex if necessary\n      if (this.minIndex < 0) {\n        this.minIndex = 0;\n        this.maxIndex = numDotsToShow - 1;\n      }\n\n      if (this.maxIndex > currentDots.length - 1) {\n        this.maxIndex = currentDots.length - 1;\n        this.minIndex = this.maxIndex - numDotsToShow + 1;\n      }\n\n      this.forceUpdate();\n    } else if (prevDots && currentDots && prevDots.length < currentDots.length) {\n      //edge case - adjust minIndex and maxIndex if active dot will be out of the View determined by min/max index\n      const currentActiveDot = currentDots.find(dot => dot.props.className === activeDotClassName);\n      let currentActiveIndex = parseInt(currentActiveDot.key);\n\n      if (currentActiveIndex >= this.maxIndex) {\n        this.maxIndex = currentActiveIndex + 1;\n        this.minIndex = this.maxIndex - numDotsToShow + 1;\n      }\n\n      //adjust minIndex and maxIndex if necessary\n      if (this.maxIndex > currentDots.length - 1) {\n        this.maxIndex = currentDots.length - 1;\n        this.minIndex = this.maxIndex - numDotsToShow + 1;\n      }\n\n      this.forceUpdate();\n    }\n  }\n\n  render() {\n    const {\n      dots,\n      numDotsToShow,\n      dotWidth,\n      dotContainerClassName,\n      activeDotClassName,\n      prevNextDotClassName\n    } = this.props;\n\n    const active = dots.find(dot => dot.props.className === activeDotClassName);\n    let adjustedDots = [...dots];\n    //if no current activeIndex, then due to react-slick breakpoint - use generated breakPointActiveIndex\n    let activeIndex = active ? parseInt(active.key) : this.breakPointActiveIndex;\n    //consider '>=' as moving forward to support react-slick breakpoint use case\n    const isMovingForward = activeIndex >= this.previousActiveIndex;\n\n    // need to subtract 2 from numDotsToShow since array index are zero-based\n    if (\n      (activeIndex > numDotsToShow - 2 && adjustedDots.length > numDotsToShow) ||\n      this.hasAnimated\n    ) {\n      if (isMovingForward) {\n        if (activeIndex === this.maxIndex && activeIndex !== dots.length - 1) {\n          // list will move left\n          this.minIndex = activeIndex - (numDotsToShow - 2);\n          this.maxIndex = activeIndex + 1;\n        } else {\n          // special case - handle if initialSlide from react-slick has a value greater than 0\n          if (this.minIndex === 0 && this.maxIndex === 0) {\n            if (activeIndex === dots.length - 1) {\n              this.maxIndex = activeIndex;\n              this.minIndex = this.maxIndex - (numDotsToShow - 1);\n            } else {\n              this.minIndex = activeIndex - 1 < 0 ? 0 : activeIndex - 1;\n              this.maxIndex =\n                this.minIndex + (numDotsToShow - 1) > dots.length - 1\n                  ? dots.length - 1\n                  : this.minIndex + (numDotsToShow - 1);\n            }\n          } else {\n            if (activeIndex === dots.length - 1) {\n              // moving carousel backward from 0 to max index\n              this.maxIndex = dots.length - 1;\n              this.minIndex = dots.length - numDotsToShow;\n            }\n          }\n        }\n      } else {\n        // movingBackwards\n        if (activeIndex === this.minIndex && activeIndex !== 0) {\n          // list will move right\n          this.minIndex = activeIndex - 1;\n          this.maxIndex = this.minIndex + (numDotsToShow - 1);\n        } else {\n          if (activeIndex === 0) {\n            // moving carousel forward from max index to 0\n            this.maxIndex = numDotsToShow - 1;\n            this.minIndex = 0;\n          }\n        }\n      }\n\n      this.hasAnimated = true;\n      const firstViewableDotIndex = this.minIndex;\n      const firstViewableDot = adjustedDots[firstViewableDotIndex];\n      const lastViewableDotIndex = this.maxIndex;\n      const lastViewableDot = adjustedDots[lastViewableDotIndex];\n\n      //outside of bounds check - can be caused when using react-slick breakpoints\n      //return null and dots will correctly re-render once componentDidUpdate lifecycle recalculates indexes\n      if (!firstViewableDot || !lastViewableDot) {\n        console.log('rendering null - outside of bounds', firstViewableDot, lastViewableDot);\n        return null;\n      }\n\n      if (lastViewableDotIndex < adjustedDots.length - 1 && isMovingForward) {\n        // moving foward - but not on the last dot\n        adjustedDots = [\n          ...adjustedDots.slice(0, firstViewableDotIndex),\n          React.cloneElement(firstViewableDot, {\n            className: prevNextDotClassName\n          }),\n          ...adjustedDots.slice(firstViewableDotIndex + 1, lastViewableDotIndex),\n          React.cloneElement(lastViewableDot, {\n            className: prevNextDotClassName\n          }),\n          ...adjustedDots.slice(lastViewableDotIndex + 1)\n        ];\n      } else if (lastViewableDotIndex === adjustedDots.length - 1) {\n        // moving foward or backward - last dot visible - should appear not small\n        adjustedDots = [\n          ...adjustedDots.slice(0, firstViewableDotIndex),\n          React.cloneElement(firstViewableDot, {\n            className: prevNextDotClassName\n          }),\n          ...adjustedDots.slice(firstViewableDotIndex + 1, lastViewableDotIndex),\n          this.addActiveClassToLastDot || activeIndex === lastViewableDotIndex\n            ? React.cloneElement(lastViewableDot, {\n                className: this.props.activeDotClassName\n              })\n            : lastViewableDot\n        ];\n      } else if (activeIndex > 1 && !isMovingForward) {\n        // moving backwards the left\n        adjustedDots = [\n          ...adjustedDots.slice(0, firstViewableDotIndex),\n          React.cloneElement(firstViewableDot, {\n            className: prevNextDotClassName\n          }),\n          ...adjustedDots.slice(firstViewableDotIndex + 1, lastViewableDotIndex),\n          React.cloneElement(lastViewableDot, {\n            className: prevNextDotClassName\n          }),\n          ...adjustedDots.slice(lastViewableDotIndex + 1)\n        ];\n      } else {\n        this.hasAnimated = false;\n        // moving backwards on first dot - should appear not small\n        // eq: (activeIndex === 1 || activeIndex === 0) && !isMovingForward\n        adjustedDots = [\n          ...adjustedDots.slice(0, lastViewableDotIndex),\n          React.cloneElement(lastViewableDot, {\n            className: prevNextDotClassName\n          }),\n          ...adjustedDots.slice(lastViewableDotIndex + 1)\n        ];\n      }\n    }\n    // no leftOffset in place, just render the dots\n    else {\n      const lastViewableDotIndex = Math.min(numDotsToShow, dots.length) - 1;\n      this.minIndex = 0;\n      this.maxIndex = lastViewableDotIndex;\n\n      if (lastViewableDotIndex < adjustedDots.length - 1) {\n        const lastViewableDot = adjustedDots[lastViewableDotIndex];\n\n        adjustedDots = [\n          ...adjustedDots.slice(0, lastViewableDotIndex),\n          React.cloneElement(lastViewableDot, {\n            className: prevNextDotClassName\n          }),\n          ...adjustedDots.slice(lastViewableDotIndex + 1)\n        ];\n      }\n    }\n\n    // track active index\n    this.previousActiveIndex = activeIndex;\n    this.addActiveClassToLastDot = false;\n    // calculate container width\n    const containerWidth =\n      dots.length < numDotsToShow ? dots.length * dotWidth : numDotsToShow * dotWidth;\n\n    const midIndex = (this.minIndex + this.maxIndex) / 2;\n\n    // only give leftOffset if number of dots exceeds number of dots to show at one time\n    const leftOffset =\n      dots.length < numDotsToShow\n        ? 0\n        : (dotWidth * numDotsToShow - dotWidth) / 2 - midIndex * dotWidth;\n\n    return (\n      <div\n        className={dotContainerClassName}\n        style={{\n          position: 'relative',\n          overflow: 'hidden',\n          margin: 'auto',\n          width: containerWidth + 'px'\n        }}\n      >\n        <ul style={{ transform: `translateX(${leftOffset}px)` }}> {adjustedDots} </ul>\n      </div>\n    );\n  }\n}\n\nMagicSliderDots.propTypes = {\n  /** array of HTML li elements representing the slider dot.   */\n  dots: PropTypes.array.isRequired,\n  /** number of slider dots to show. */\n  numDotsToShow: PropTypes.number.isRequired,\n  /** width, in pixels, of a slider dot including any margins/padding. */\n  dotWidth: PropTypes.number.isRequired,\n  /** class name of parent div. */\n  dotContainerClassName: PropTypes.string,\n  /** class name of active slider dot. */\n  activeDotClassName: PropTypes.string,\n  /** class name of left-most (prev) and right-most (next) slider dot. */\n  prevNextDotClassName: PropTypes.string\n};\n\nMagicSliderDots.defaultProps = {\n  dotContainerClassName: 'magic-dots slick-dots',\n  activeDotClassName: 'slick-active',\n  prevNextDotClassName: 'small'\n};\n"]},"metadata":{},"sourceType":"module"}